## Beans are available in spring context and manage through spring context
## ApplicationConfig is also spring bean -It is used to create others
## ApplicationContext context = SpringApplication.run(ApplicationConfig.class); it also create all component egarly in config class
## Abc abc = context.getBean("abc"(bean id),ABC.class); OR Abc abc = (ABC) context.getBean("Abc"); OR Abc abc = context.getBean(Abc.class);
## application context can be created in any env like standalone apk, web app,junit test
## handle multiple config using @import({AbcConfig.class,XyzConfig.class})
## default bean scop is singleton eq @Scop("singleton") in this case need to handle multiple threading
    Abc abc1 = (Abc)context.getBean(("abc");
    Abc abc2 = (Abc)context.getBean(("abc");
    abc1 == abc2 // True

    ## How Can we handle multi theading in above case ?
      - Use Statless or immutable beans
      - Use synch. (header)
      - Use differnet scop

  # prototype scop give each time create bew instance @Scop("prototype")
    Abc abc1 = (Abc)context.getBean(("abc");
    Abc abc2 = (Abc)context.getBean(("abc");
    abc1 != abc2 // True

  # @Scop("session") new instance created per user session and destroy with session (web env only)
  # @Scop("request" new instance creaate per request (web env only)



## Enviroment env => env.getProperty("abc.xyz")  // read value from property file 
    # env take propery from property source 
    # need to add @PropertySource("classpath:com/../../app.property") on class
        * Alternate
    # you can use @Value("${abc.xyz}")

## If you want to create profile specific bean 
    # anotate class with @Profile("xyz") so when xyz profile activated then only bean created for following class

    # Activate profile at run time // -DSpring.profile.active = xyz
    # it also intialize configuration class which not have @Profile annotation

## expretion Lang
    # @Value("#{systemProperty[abc.xyz]}) // here systemProperty implicit variable provide by spring

    # we have class Abc which have method getKeyGen which return object of KeyGen and we create bean of Abc then 
        @Bean
        public Abc abc(){return new Abc();}
        # @Value("#{abc.keyGen} KeyGen keyGen;

    # propertes are string @Value(#{new Integer(systemProperty[abc.xyz])}) Integer abc;
    # "${abc.xyz:1000} // here 1000 is default value

## Spring supports multiple types annotations such as @Component,@Controller,@service @Repository and @Bean. All theses can be found under the 
        org.springframework.stereotype package.

    When classes in our application are annotated with any of the above mentioned annotation then during project startup spring scan(using @componentScan) 
        each class and inject the instance of the classes to the IOC container. Another thing the @ComponentScan would do is running the methods with 
        @Bean on it and restore the return object to the Ioc Container as a bean.

   
Sr. No.	Key	
    @Bean	
    @Component
1 Auto detection
    It is used to explicitly declare a single bean, rather than letting Spring do it automatically. 
    If any class is annotated with @Component it will be automatically detect by using classpath scan.

2 Spring Container
    Bean can be created even class is outside the spring container
    We can’t create bean if class is outside spring container

3 Class/Method  Level Annotation
    It is a method level annotation
    It is a class level annotation

4 @Configuration
    It works only when class is also annotated with @Configuration
    It works without @Configuration annotation

5 Use Case
    We should use @bean, if you want specific implementation based on dynamic condition.
    We can’t write specific implementation based on dynamic condition

## @Autowired => construction , method , field
    Autowired default behaviour is Required if  it not found bean at runtime then throw error to avoid that use @Autowired(required = false)
        Alternative of above is use optional
        @Autowired
        public void setDisplay(Optional<Display> display){
            this.display = display;
        }

## Constructor Injection vs Setter Injection in Spring
    Sr. No.	Key	
        Constructor based Injection	
        Setter based Injection

1 Circular
    It doesn’t allow to create circular dependency
    It doesn’t check the circular dependency

2 Ordering
    Constructor-based DI fixes the order in which the dependencies need to be injected.
    Setter-based DI helps us to inject the dependency only when it is required, as opposed to requiring it at construction time.

3 MutilThread Environment  
    Combining with final fields, constructor injection gives extra safety in multithreaded environment
    No extra benefit in setter injection

4 Spring Code generation Library
    Spring code generation library doesn’t support constructor injection so it will not be able to create proxy. It will force you to use no-argument constructor.  
    Spring framework level code uses setter injection

5 Use Case
    It should be used for mandatory dependencies
    It should be used for optional dependencies.

## If There is more then one component with same type (eg: clasess which implement same interface) now you try to autowired that component
        (eg: interface parent of that two class) it will give error because it found more then one bean with same type
        in that caase use @Qualifier("beanName")(bean name is simply component name)
## Every thing egerly intialize if yoou want to lazy it use @Lazy

## if Class only has default constructor nothing to do
    if class has one non default constructor spring will use it (autowired not required)
    if class has more then one non default constructor then spring will use zero arg constructor y default (if exist)
        or you must anotate with @Autowire the one you want spring to use

## Component scan at startup JAR dep also scan so if application is large it will increase startup time for the issue use component scan like wise

## @postConstruct and @preDestroy takes no parameter and only return void
    postConstruct => method call at startup after all dep injected
    preDestroy => method call at shut down prior to destroying the bean instance
     - this are not spring annotation , it defined by JSR-250 it's part of Java since java 6
     - it's in javax.annotation pkg supported by spring and java EE

    preDestroy methods call only if application shut down normally
    contex.close() => Call predestroy methods  jvm shutdown hook automatically close context for you

    Alternativie use @Bean(initMethod = "populateCache" , destroyMethod="clearCache")

## Stereotype annotation @Component => @Service , @Repository , @Controller @RestController , @configuration
    Custom annotation 

        @Retention(RetentionPolicy.runtime)
        @Target(ElementType.Type)
        public @interface annotationName(){
            String value() default "";
        }

## Container Lifecycle => intialization , usage , destruction
    - intialization : when context created intialize phase is complated 
        - P1:Load and process bean defination
            - Bean defination added to BeanFactory(each index under it's id and type)
            - Special BeanFactoryPostProcessor bean invoked (can modify the defination of any bean)
            - Application context is beanFactory
            - you can write your own BeanFactoryPostProcessor by implementing  it 
        - P2:Perform Bean creation
            - find/create it's dependency
            - each singleton bean egarly intialized(until it's mark as lazy)
            - each bean go through post processing (BeanPostProcessor)

        - Intializer Extention point
            - special case of bean post-processing
                - cause intialize method call (eg @PostConstruct and init-method)
            - internally spring uses several intializer BPP's
                - eg CommonAnnotationBeanPostProcessor enables @postconstruct and @resource

        - Bean post processor extention point
            - Can modify bean instance in any way
            - powerfull enabling feature
            - will run againest eveery bean
            - can modify bean before and after intialization 
                - beforeIntit runs before intialization
                - afterIntit runs after intialization

    - Use Phase: 
        - case 1: your bean is just bean (bean is just row object simply invoked directly)
        - case 2: your bean is proxy (if you need some extra behaviour like transaction and etc context return proxy bean)
            - proxy creation done at intialize process by bean post processor
            - Spring AOP is proxy based. Spring used two types of proxy strategy one is JDK dynamic proxy and other one is CGLIB proxy.
            - JDK dynamic proxy is available with the JDK. It can be only proxy by interface so target class needs to implement interface. 
                In your is implementing one or more interface then spring will automatically use JDK dynamic proxies.
            - On the other hand, CGLIB is a third party library which spring used for creating proxy. It can create proxy by subclassing. 
                Spring uses CGLIB for proxy if class is not implementing interface.

            Sr. No.	Key	
                JDK dynamic proxy	
                CGLIB proxy
            
            1 Basic
                It can be only proxy by interface so target class needs to implement interface
                It can create proxy by subclassing

            2 Package
                It is available with the Java
                It is a third  library.

            3 Performance
                It is a bit slow than CGLIB proxy
                It is faster than JDK dynamic proxy

            4 Final
                Final class and Final method can not be proxy
                Final class and Final method can not be proxy

            5 Use case
                Spring uses JDK proxy when is class is implementing one or more interface
                Spring uses CGLib proxy when class in not implementing interface

    - destruction phase:(context is close or shut down hook invoked)
        - Bean clean up
            - @predestroy execute
            - bean relesed for garbage collector 
        - Also happen when any bean goes out of scope (except prototype bean scope)

    - Creating dependency
        - Bean created after their dependencies you can tell it spring explisitly by @DependsOn()

        - problem
            - Aim to be sufficiently expressive
            - return interfaces except (where  multiple interfaces exist , and they are needed for dep injection)
            - Warning: even if you return impl type (still using interfaces when injecting dep , injecting impl type is brittle

## AOP : enables modularization of cross-cutting concerns
        - cross-cutting concerns: Gen functionality that is needed in many places  (eg: logging , tracing,transaction ,security, error handling etc)
        - impl ccc without modulerization (code tangling , code scattring)

    - Use AOP in your application
        - impl mainline apk logic (focus on core problem)
        - write aspect to impl your ccc
        - wave aspect into your apk

    - Leading AOP Tech
        - AspetJ (original aop tech)
            A full bown aspect orianted programming (uses byte code injection)

        - Spring AOP
            Java based AOP framework with AspectJ integration(uses proxy for aspect weaving)

    - Core AOP Concept
        - join point(A point in execution of program such as method call or exception throwing)
        - point cut (A expression that selects one or more join points)
        - advice (code to be executed at each selected point)
        - aspect (module that encapsulates pointcuts and advice)
        - weaving (Technique by which aspects are combined with main code)

        - AOP proxy (An "enhanced" class that stands in place of your original class with extra behaviour added into it 

            * matches one , .. matches one or more
        - Exp => execution(* com.type.*Service.find*(..)
            method which start with find have one or more argument which is inside class which ends with service and pkgcom.type with any return type
            







    












