## Spring 
  - Spring is a comprehensive framework that provides various modules for building different types of applications.
  - we will use Spring MVC for the web application, Spring Data for data access, and Spring Security for authentication and authorization. 
  - Setting up a Spring application requires a lot of configuration, and developers need to manually configure various components of the framework to get an application up and running.

## Spring boot
  - Spring Boot is like a more opinionated version of Spring. It comes with many pre-configured settings and dependencies that are commonly used in Spring applications.
  - Spring Boot is a more opinionated, streamlined version of Spring that comes with a lot of built-in features to help you get started quickly and easily.

## Spring's Inversion of Control Container
  - Spring Boot allows you to configure how and when dependencies are provided to your application at runtime. This puts you in control of how your application operates in different scenarios.
  - Inversion of control is often called dependency injection (DI), though this is not strictly correct. Dependency injection and accompanying frameworks are one way of achieving inversion of control
  - The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans

## Test Driven Development
  - we'll write tests before implementing the application code. This is called test driven development (TDD)

##  REST: Representational State Transfer
  -  The purpose of a RESTful API (Application Programming Interface) is to manage the state of these Resources.

## Idempotence and HTTP
  - An idempotent operation is defined as one which, if performed more than once, results in the same outcome.
  - GET, PUT, and DELETE are idempotent, whereas POST and PATCH are not.

## Regarding Unordered Queries
  - Although Spring does provide an “unordered” sorting strategy.

## Spring Data Pagination API
  - Spring Data provides the PageRequest and Sort classes for pagination. 
  - Page<CashCard> page2 = cashCardRepository.findAll(
    PageRequest.of(
        1,  // page index for the second page - indexing starts at 0
        10, // page size (the last page might have fewer items)
        Sort.by(new Sort.Order(Sort.Direction.DESC, "amount"))));
  - Pagination: Spring can parse out the page and size parameters if you pass a Pageable object to a PagingAndSortingRepository find…()method.
  - Sorting: Spring can parse out the sort parameter, consisting of the field name and the direction separated by a comma – 
      but be careful, no space before or after the comma is allowed! Again, this data is part of the Pageable object.

## Spring Security and Authentication
  - Spring Security implements authentication in the Filter Chain. The Filter Chain is a component of Java web architecture which allows programmers to define a sequence of methods that get called prior to the Controller.
      Each filter in the chain decides whether to allow request processing to continue, or not.

## Cross-Origin Resource Sharing
  - Spring Security provides the @CrossOrigin annotation, allowing you to specify a list of allowed sites. Be careful!
       If you use the annotation without any arguments, it will allow all origins, so bear this in mind!

## Cross-Site Request Forgery
  - One type of vulnerability is a Cross-Site Request Forgery (CSRF) which is often pronounced “Sea-Surf”, 
      and also known as Session Riding. Session Riding is actually enabled by Cookies. CSRF attacks happen when a malicious piece of code 
      sends a request to a server where a user is authenticated. When the server receives the Authentication Cookie, it has no way of knowing 
      if the victim sent the harmful request unintentionally.

  - To protect against CSRF attacks, you can use a CSRF Token. A CSRF Token is different from an Auth Token because a unique token is generated on each request. 
      This makes it harder for an outside actor to insert itself into the “conversation” between the client and the server.

  - Thankfully, Spring Security has built-in support for CSRF tokens which is enabled by default.

## Cross-Site Scripting
  -Perhaps even more dangerous than CSRF vulnerability is Cross-Site Scripting (XSS). This occurs when an attacker is somehow able to “trick” the victim application into executing arbitrary code. 
      There are many ways to do this. A simple example is saving a string in a database containing a <script> tag, 
      and then waiting until the string is rendered on a web page, resulting in the script being executed.

  - XSS is potentially more dangerous than CSRF. In CSRF, only actions that a user is authorized to do can be executed. 
      However in XSS, arbitrary malicious code executes on the client or on the server. Additionally, XSS attacks don’t depend on Authentication. 
      Rather, XSS attacks depend on security “holes” caused by poor programming practices.

  - The main way to guard against XSS attacks is to properly process all data from external sources (like web forms and URI query strings). 
      In the case of our <script> tag example, attacks can be mitigated by properly escaping the special HTML characters when the string is rendered.

## PUT and PATCH
  - Both PUT and PATCH can be used for updating, but they work in different ways. Essentially, PUT means “create or replace the complete record”,
      whereas PATCH means “update only some fields of the existing record” - in other words, a partial update.

